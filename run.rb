require 'xcodeproj'
require  File.join("./",'./utils.rb')
require 'pathname'
require 'yaml'



p ""
p ""
p "======== loading config ========"

config = YAML.load(File.open(Pathname.new("./config.yaml")))
run_config = YAML.load(File.open(Pathname.new("./run.yaml")))

commit_hash = run_config["commit_hash"];


# 命令行当前支持一个参数:
# 1. project_file_path，工程文件的绝对路径文件名（文件名）。
# 使用举例：
# ruby run.rb /dir1/dir2/ios-bi-demo.xcodeproj

# 注意:
# 1.  若在命令行参入project_file_path，同时在config.yaml中传入定义了project_file_path，则优先使用命令行传入的参数值。
# 2.  targetName只能从config.yaml中配置。

targetName = config["targetName"];
basic_target_name= config["targetName"].to_s+".xcodeproj"
project_file_path=""

p "basic_target_name = " + basic_target_name

# 0.通过读取命令行参数，检查是否为纯编辑模式。纯编辑模式下，不会创建新的target，而是直接修改指定的target.
isEdit = false
if ARGV.include? "--edit"
   isEdit = true
end

p "isEdit = " + isEdit.to_s

# 1.通过读取命令行参数，设置project_file_path
if ARGV.length>0 && File.exist?(ARGV[0].to_s) && (ARGV[0].to_s.split('/')[-1].to_s.include? ".xcodeproj")
    if ARGV[0].to_s.split('/')[0] == "."
        project_file_path = Dir.pwd + "/"+ ARGV[0].to_s
        p "project path is relative,path is " + project_file_path
        
        elsif File.exist?(ARGV[0].to_s)
        p "project file found, will use ARGV[0]"
        project_file_path = ARGV[0].to_s
    end
   # 2.该分支仅用于适配run.command，以便无需配置project_file_path, 直接在当前目录打包。
elsif ARGV.length>0 && File.exist?(ARGV[0].to_s+"../"+basic_target_name)
   p "project file found, will use ARGV[0]+basic_target_name"
   project_file_path = ARGV[0].to_s+"../"+basic_target_name
   p "project_file_path is :"+project_file_path
   # 3.只有当根据命令行参数，无法找到有效的工程文件时，才会通过读取config.yaml，设置project_file_path
else
    p "No valid argument param found , will use all config in config.yaml ..."
    if config["project_file_path"].to_s.split('/')[0] == "."
        project_file_path = Dir.pwd + "/"+ config["project_file_path"].to_s
        p "project path is relative,path is " + project_file_path
    
    elsif File.exist?(config["project_file_path"].to_s)
        p "project file found, will use config"
        project_file_path = config["project_file_path"].to_s
    end
    p "project_file_path is :"+project_file_path
end

p "project_file_path is :"+project_file_path

# xgsdk_sdkAppid=config["xgsdk_sdkAppid"].to_s
# xgsdk_sdkAppkey=config["xgsdk_sdkAppkey"].to_s

# p "sdk_app_id is: "+xgsdk_sdkAppid
# p "sdk_app_key is: "+xgsdk_sdkAppkey
# # p puts Pathname.new(File.dirname(__FILE__)).realpath

# # the following params is provided by user...
# xgsdk_appid=config["appId"].to_s
# xgsdk_appkey=config["appKey"].to_s
sdk_channelName=config["sdk_channelName"].to_s
bundle_id = config["bundle_id"].to_s
url_sheme_name = bundle_id+".alipay"
# XgRechargeUrl = config["XgRechargeUrl"].to_s
# XgAuthUrl = config["XgAuthUrl"].to_s
# XgDataUrl = config["XgDataUrl"].to_s

# the following params is generated by the params listed above...
p "======== initializing ========"
if basic_target_name==nil
   p "no availabel target found,will use default target name from xcodeProj"
   basic_target_name = project_file_path.split('/')[-1]
else
   p "target name is:"+basic_target_name
end

sdk_target_name = sdk_channelName+"_"+targetName
sdk_group_name= sdk_target_name
sdk_product_name= sdk_target_name+".app"
sdk_plist_name = sdk_target_name+"_info.plist"
project_path= project_file_path.split('/').slice(0..-2).join('/')

pathname = Pathname.new(File.dirname(__FILE__)).realpath+""
res_path = pathname.to_s.split(":")[0]+"/res"

p "res_path = " + res_path

# relative path
relative_res_path = "$(SRCROOT)"+"/SDK_Plugin"+res_path.split("SDK_Plugin")[1];
relative_info_path = "$(SRCROOT)/SDK_InfoPlist";

p "relative_res_path is: "+relative_res_path
p "relative_info_path is: "+relative_info_path


p "res_path is..."
p res_path
xcode_system_path = "/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"
system_lib_path = xcode_system_path +"/usr/lib"
system_framworks_path = xcode_system_path + "/System/Library/Frameworks"
info_path = project_path+"/SDK_InfoPlist"
tag_file = info_path+"/tag_info.plist"
temp_file = info_path+"/temp_info.plist"
dest_file = info_path +"/"+sdk_target_name+"_info.plist"
relative_dest_file = relative_info_path+"/"+sdk_target_name+"_info.plist"


basicTarget = nil
newTarget = nil
executeTarget = nil

#-------------------------------------------------------------------------

p ""
p "1: ======== clear the old target and group ========"
proj = Xcodeproj::Project.open(project_file_path)
#proj.recreate_user_schemes
# find basic target
basicTarget=Utils::GameSDK.findBasicTarget(proj,basic_target_name)

if basicTarget==nil
   p "======> target name config error !!! will return... "
   return
end



product_group=Utils::GameSDK.getProductGroup(proj)


# 非edit模式，需要delete old target
if !isEdit
   Utils::GameSDK.clearOldTarget(proj,sdk_target_name)
   Utils::GameSDK.clearOldProduct(proj,sdk_product_name)
end

# 非edit模式，需要创建新target
if !isEdit
   p "create: target"
   newTarget = proj.new_target(:application,sdk_target_name,:ios,nil,product_group)
end

# 非edit模式，执行的target为newTarget
if !isEdit
   executeTarget = newTarget
else
   executeTarget = basicTarget
end

p "create: group"
plugin_group = Utils::GameSDK.creatNewGroup(proj,"SDK_Plugin")
sdk_group = Utils::GameSDK.creatNewGroup(plugin_group,sdk_group_name)
sdk_group.clear
library_group=sdk_group.new_group("library")
framework_group=sdk_group.new_group("framework")
srouce_group=sdk_group.new_group("src")
bundle_group=sdk_group.new_group("bundle")


#-------------------------------------------------------------------------
p ""
p "2: ======== copy and update build setting ========"
# p basicTarget.build_settings("Debug")

# 非edit模式，需要拷贝target
if !isEdit
   p "copy: build setting"
   Utils::GameSDK.copyBuildSetting(newTarget,basicTarget)
end


p "update: other link flag..."
Utils::GameSDK.addOtherLinkFlag(executeTarget,run_config["otherLinkFlag"])
#Utils::GameSDK.addCodeSignPath(executeTarget,"$(SDKROOT)/ResourceRules.plist")
Utils::GameSDK.addRunSearchPath(executeTarget,"$(inherited) @executable_path/Frameworks")
if run_config["CxxLibraryConfig"]!=nil
   p "will modify c++ lib ..."
   Utils::GameSDK.addCPlusLibConfig(executeTarget,run_config["CxxLibraryConfig"])
end


if run_config["isDisableBitCode"]
   p "will disable bitcode ..."
   Utils::GameSDK.disableBitCodeFlag(executeTarget)
end


p "update: searchPath..;"
Utils::GameSDK.addFrameSearchPath(executeTarget,[relative_res_path+"/frame"])
Utils::GameSDK.addLibSearchPath(executeTarget,[relative_res_path+"/lib"])
Utils::GameSDK.addHeaderSearchPath(executeTarget,[relative_res_path+"/src"])
p "----"
# p newTarget.build_settings("Release")

p "update: plist..."
plist_path_name = executeTarget.build_settings("Debug")["INFOPLIST_FILE"]
proj_file = project_path+"/"+plist_path_name

if (!File.directory?(info_path))
   p "will create dir.."
   Dir::mkdir(info_path)
end


p "build tag file..."
hashPlist = nil


# 非edit模式，需创建tag文件解决中文bug
if !isEdit
   Utils::GameSDK.buildTagFile(proj_file,tag_file)
   hashPlist = Xcodeproj::PlistHelper.read(tag_file)
else
   hashPlist = Xcodeproj::PlistHelper.read(proj_file)
end

# 非edit模式，需要强制去除闪屏选项。
if !isEdit
   # fix unity version screenLaunch bug
   if hashPlist["UILaunchImages"]!=nil
      hashPlist["UILaunchImages"]=[]
   end
   # fix screenLaunch bug for iphone4s ios8.3
   if hashPlist["UILaunchStoryboardName~iphone"]!=nil
      hashPlist.delete("UILaunchStoryboardName~iphone")
   end
end


# do version synchronize
if run_config["isVersionSynchronizesNeed"]!=nil&&run_config["isVersionSynchronizesNeed"]
   if hashPlist["CFBundleVersion"]!=nil
      p "will do version synchronize..."
      hashPlist["CFBundleShortVersionString"]=hashPlist["CFBundleVersion"]
   end
end

if run_config["isNeedPortrait"]!=nil&&run_config["isNeedPortrait"]
   p "update: add portrait orientation,and make portrait first..."
   # resort orientation keys to make portrait first, then, we fix screenLaunch bug in iphone4s on ios8.3
   add_orient="UIInterfaceOrientationPortrait"
   if hashPlist["UISupportedInterfaceOrientations"]!=nil
      temp_List=[add_orient]
      temp_List=temp_List+hashPlist["UISupportedInterfaceOrientations"]
      hashPlist["UISupportedInterfaceOrientations"]=temp_List
   else
      hashPlist["UISupportedInterfaceOrientations"]=[add_orient]
   end
end


p "update: add sdk info..."
Utils::GameSDK.createHashValue(hashPlist,"sdk_target_name",sdk_target_name)
Utils::GameSDK.createHashValue(hashPlist,"CFBundleIdentifier",bundle_id)

p "update: Localization_native_development_region..."
if run_config["Localization_native_development_region"]!=nil
   Utils::GameSDK.createHashValue(hashPlist,"CFBundleDevelopmentRegion",run_config["Localization_native_development_region"])
else
   p "no Localization_native_development_region is configged..."
end

p "update: add key in original plist..."
if run_config["originalPlist"]!=nil
   run_config["originalPlist"].each do |k,v|
      config_key = v.split("$")[1]
      value=""
      # 若配置了“$”,则需要读取config.yaml文件
      if config_key!=nil
          config_value = config[config_key]
          value = v.split("$")[0].to_s+config_value.to_s+v.split("$")[2].to_s
          if config_key== "true"
              value = true
          elsif config_key== "false"
              value = false
          end
      end
      Utils::GameSDK.createHashValue(hashPlist,k,value)
   end
end

# 在info.plist中添加GameCenter key值，以支持gamecenter
if run_config["isGameCenterNeed"]!=nil && run_config["isGameCenterNeed"]
   p "will add gamekit key...."
   Utils::GameSDK.addGameKitKey(hashPlist)
end

p "update: add url scheme..."
urlTypeList = run_config["urlTypeList"]
for item in urlTypeList
   new_schemes=[]
   for i in item["CFBundleURLSchemes"]
      config_key = i.split("$")[1]
      # 若配置了“$”,则需要读取config.yaml文件
      if config_key!=nil
         config_value = config[config_key]
         i = i.split("$")[0].to_s+config_value.to_s+i.split("$")[2].to_s
         new_schemes<<i
      end
   end
   item["CFBundleURLSchemes"]=new_schemes

   #   将CFBundleURLName的参数实例化
   CFName_value = item["CFBundleURLName"]
   if CFName_value!=nil
      config_key_CFName = CFName_value.split("$")[1]
      # 若配置了“$”,则需要读取config.yaml文件
      if config_key_CFName!=nil
         config_value_CFName = config[config_key_CFName]
         p "CFName value is "+config_value_CFName
         CFName_value = CFName_value.split("$")[0].to_s+config_value_CFName.to_s+CFName_value.split("$")[2].to_s
         item["CFBundleURLName"]=CFName_value
      end
   end
end



#p hashPlist["CFBundleURLTypes"]
if hashPlist["CFBundleURLTypes"]!=nil
   for urltype in urlTypeList
      is_need_add_flag = true
      for j in hashPlist["CFBundleURLTypes"]
         # 如果已经存在，则不追加
         if ["CFBundleURLName"]==urltype["CFBundleURLName"]
            is_need_add_flag=false
            break
         end
      end
      if is_need_add_flag
         hashPlist["CFBundleURLTypes"]<<urltype
      end
   end
else
   hashPlist["CFBundleURLTypes"]=urlTypeList
end


if run_config["ios9HttpEnable"]!=nil
   p "add https trans config for iOS9"
   hashPlist["NSAppTransportSecurity"]={"NSAllowsArbitraryLoads"=>run_config["ios9HttpEnable"]}
end

if hashPlist["LSApplicationQueriesSchemes"]==nil && run_config["ios9Urlschemes"]!=nil then
   p "add urlSchemes config for iOS9"
   hashPlist["LSApplicationQueriesSchemes"]=run_config["ios9Urlschemes"]
elsif  hashPlist["LSApplicationQueriesSchemes"]!=nil && run_config["ios9Urlschemes"]!=nil then
   p "modify urlSchemes config for iOS9"
   hashPlist["LSApplicationQueriesSchemes"]<<run_config["ios9Urlschemes"]
end




p "save: plist..."
# 非edit模式，需要回写tag文件，以更新plist。
if !isEdit
   Xcodeproj::PlistHelper.write(hashPlist,temp_file)
   Utils::GameSDK.buildDestFile(temp_file,dest_file);
   Utils::GameSDK.deleteFiles([temp_file,tag_file])
   newTarget.build_settings("Debug")["INFOPLIST_FILE"]=relative_dest_file
   newTarget.build_settings("Release")["INFOPLIST_FILE"]=relative_dest_file
   flag = Utils::GameSDK.isFileExist(sdk_group.files,sdk_target_name+"_info.plist")
   if flag=="no"
      sdk_group.new_file(dest_file)
   end
else
   Xcodeproj::PlistHelper.write(hashPlist,proj_file)
end

# 非edit模式，需要拷贝target
if !isEdit
   p "3: ======== copy and update build phase ========"
   Utils::GameSDK.copyBuildPhase(newTarget,proj,basicTarget)
end

p "update: add lib..."
user_lib_List = run_config["user_libs"]

# # 添加用户库
# for item in user_lib_List
#    Utils::GameSDK.setBuildPharse(executeTarget,library_group,res_path+"/lib/"+item)
# end

# 添加系统库
sys_lib_List = run_config["system_libs"]
for item in sys_lib_List
   Utils::GameSDK.setBuildPharse(executeTarget,library_group,system_lib_path+"/"+item)
end


# p "update: add framework..."
# # 添加用户framework
# user_frame_List = run_config["user_frameworks"]
# for item in user_frame_List
#    Utils::GameSDK.setBuildPharse(executeTarget,framework_group,res_path+"/frame/"+item)
# end

# 添加系统framework
sys_frame_List = run_config["sys_frameworks"]
for item in sys_frame_List
   p item
   Utils::GameSDK.setBuildPharse(executeTarget,framework_group,system_framworks_path+"/"+item)
end

# 添加动态嵌入framework
if run_config["embbed_frameworks"]!=nil&&run_config["embbed_frameworks"].length > 0
   for emb_frame in run_config["embbed_frameworks"]

      p "add embed file: "+emb_frame
      embed_file=nil
      for file in framework_group.files
         if file.name == emb_frame
            embed_file=file
            break
         end
      end

      copyFile = executeTarget.new_copy_files_build_phase
      copyFile.dst_path=""
      copyFile.name="Embed Frameworks"
      copyFile.dst_subfolder_spec="10"
      copyFile.run_only_for_deployment_postprocessing="0"
      copyFile.add_file_reference(embed_file,true)


      # add code sign attributes
      for file in copyFile.files
         p file.file_ref
         if file.file_ref.name == emb_frame
            file.settings={"ATTRIBUTES"=>["CodeSignOnCopy"]}
            break
         end
      end

   end
end

# p "update: add bundle..."
# # 添加bundle
# user_bundle_List = run_config["user_bundles"]
# for item in user_bundle_List
#    Utils::GameSDK.setResoucePharse(executeTarget,bundle_group,res_path+"/bundle/"+item)
# end
# # Utils::GameSDK.setResoucePharse(executeTarget,bundle_group,gamesdk_info_file)


#添加src下的源码文件 及源码指定编译flag
p "update: add srouce..."
if run_config["source_files"].length >0
   for item in run_config["source_files"]
      Utils::GameSDK.setSourceFilePharse(executeTarget,srouce_group,res_path+"/src/"+item["file_name"])

      # 添加编译选项
      for file in executeTarget.source_build_phase.files
         p file.file_ref
         if file.file_ref.name == item["file_name"]
            file.settings={"COMPILER_FLAGS"=>item["complier_flag"]}
            break
         end
      end

   end
end


p "update: add srouce...src dir"

#src_array = Dir::entries(res_path)

# #p "-------------src_array lengt==========" + src_array.length.to_s
# for item in src_array
#   p "item name = " + item
#   if item != '.' && item != '..'
#     if File.directory?("#{res_path}/#{item}")
#       p "Dir=" + item
#     else
#       p item
#     end
#       Utils::GameSDK.setSourceFilePharse(executeTarget,srouce_group,res_path+"/"+item)
#   end
# end

#遍历src目录并将文件加入xcodeproj引用
def addSrcDir(path,target,group)
  tem_dir = ""
  Dir.entries(path).each do |sub|
    if sub != '.' && sub != '..' && sub != '.DS_Store'
      if File.directory?("#{path}/#{sub}")
        p "Dir=" + sub
        name = File.basename(sub)
        p "name="+name
        #framework文件
        if name.include?".framework"
          p 'framework========'
          Utils::GameSDK.setBuildPharse(target,group,path+"/"+sub)
        elsif name.include?".bundle"
          p 'bundle======'
          Utils::GameSDK.setResoucePharse(target,group,path+"/"+sub)
        else
          addSrcDir("#{path}/#{sub}",target,group)
        end
      else
        p "sub:"+sub
        name = File.basename(sub)
        p "name="+name
        if name.include?".a"
          p '.a========'
          Utils::GameSDK.setBuildPharse(target,group,path+"/"+sub)
        elsif name.include?".h" or name.include?".m" or name.include?".mm" or name.include?".c"
          p 'add src file'
          Utils::GameSDK.setSourceFilePharse(target,group,path+"/"+sub)
        elsif name.include?".plist"
          p 'add plist file name=' + name
          Utils::GameSDK.setResoucePharse(target,group,path+"/"+sub)  
        else
          p "*********other file name =" + name
          Utils::GameSDK.setSourceFilePharse(target,group,path+"/"+sub)
        end
      end
    end
  end
end
addthing_group=sdk_group.new_group("addthing")
addSrcDir(res_path+"/addthing",executeTarget,addthing_group)


# 非edit模式下，需增加unity属性拷贝
if !isEdit
   p "add unity setting if need..."
   Utils::GameSDK.makeUnitySetting(project_path,proj,executeTarget)
end

if run_config["isReplaceIconNeed"]!=nil && run_config["isReplaceIconNeed"]
   p "add: icon resouce..."
   imagePath = Pathname.new(File.dirname(__FILE__)).realpath + "Images.xcassets"
   desImgPath = File.expand_path("..",project_file_path)+ "/" + config["targetName"]
   system "unzip -o ./Images.xcassets.zip -d #{desImgPath}"
   
   Utils::GameSDK.resetIconPath(newTarget,xgsdk_channelid)
   #end
   p "======== end ========"
end

proj.save
